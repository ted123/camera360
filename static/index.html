<!--
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// Experiments   - github.com/muaz-khan/WebRTC-Experiment
-->

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>RecordRTC over Node.js</title>
        <script>
            if (location.href.indexOf('file:') == 0) {
                document.write('<h1 style="color:red;">Please load this HTML file on HTTP or HTTPS.</h1>');
            }
        </script>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link rel="author" type="text/html" href="https://plus.google.com/+MuazKhan">
        <meta name="author" content="Muaz Khan">
        <script src="/js/lib/recorder.js"> </script>
       
    </head>
    <body>
        
        <!--- inserting files -->
        <div id='container'>
          
               
              
               

            <!-- INTRUDER ALERT! -->

            <audio id="suspenseMusic" controls>
                <source src="/intruderalert.mp3" type="audio/mpeg">
                Your browser does not support the audio element.
            </audio>
        </div>

        <script src='/js/lib/adapter.js'></script>
        <script src='/js/lib/resemble.js'></script>
 
        <!--- done inserting -->



        <h1><a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RecordRTC">RecordRTC</a> <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RecordRTC/RecordRTC-to-Nodejs">over Node.js</a></h1>
        <p>
             <canvas id='c1' style='-webkit-filter: grayscale(100%);'></canvas>
                <video id='localVideo' autoplay></video> 
             <canvas id='c2' style='-webkit-filter: grayscale(100%);'></canvas>
            
        </p><hr />
        

    <!-- motion detector -->
    <script>
    var localVideo = document.querySelector('#localVideo');
    var masterStream='';
    var videoRecorder;
    var camerainit=true;
    var pendingSave=false;
    var errorCallback = function(e) {
        console.log('Reeeejected!', e);
    };

    navigator.getUserMedia({video: true, audio: true}, function(localMediaStream) {
        var video = localVideo;
        video.src = window.URL.createObjectURL(localMediaStream);
        masterStream = localMediaStream;
    }, errorCallback);


    document.addEventListener('DOMContentLoaded', function(){
        var v = document.getElementById('localVideo');
        var canvas1 = document.getElementById('c1');
        var canvas2 = document.getElementById('c2');
        var context1 = canvas1.getContext('2d');
        var context2 = canvas2.getContext('2d');

        var cw1 = canvas1.clientWidth ;
        var ch1 = canvas1.clientHeight ;
        var cw2 = canvas2.clientWidth ;
        var ch2 = canvas2.clientHeight ;

        v.addEventListener('play', function(){
            draw(this,context1,context2,cw1,ch1,cw2,ch2);
        },false);
    },false);

    function draw(v,c1,c2,w1,h1,w2,h2) {

    if(v.paused || v.ended) return false;

    c1.drawImage(v, 0, 0, w1, h1); 

    setTimeout( function () {
      c2.drawImage(v, 0, 0, w2, h2);

    },2000  );

    setTimeout( function () {  
         var a = document.getElementById('c1');
         var b = document.getElementById('c2');
        // if(a!=b){
        //  console.log('intruder alert');
        // }
        resembleControl = resemble(convert(a)).compareTo(convert(b)).onComplete(function(data){
            
            var error = parseInt(data.misMatchPercentage);
            console.log(error);
            console.log('hahahah' + camerainit);
            if( error > 24 ){
                if( !camerainit && !pendingSave  ){
                    window.playSound();
                    startCulpritRecording();
                    var t = 1*(60 *1000);
                    setTimeout( function () {
                        stopCulpritRecording();
                        pendingSave = false;
                    }, t );
                    pendingSave = true;          
                } else {
                    camerainit = false;
                }
                
            }
            setTimeout(draw,50,v,c1,c2,w1,h1,w2,h2);
        });

    },3100  );

    }

    function getBase64Image(canvas) {

    // Get the data-URL formatted image
    // Firefox supports PNG and JPEG. You could check img.src to
    // guess the original format, but be aware the using "image/jpg"
    // will re-encode the image.
    var dataURL = canvas.toDataURL("image/png");

    return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
    }

    function convert(canvas) {
    return canvas.toDataURL("image/png");
    }



    window.playSound = function() {
    document.getElementById('suspenseMusic').play();
    if (document.getElementById('suspenseMusic').ended) {
        document.getElementById('suspenseMusic').currentTime = 0;
        document.getElementById('suspenseMusic').play();
    }
    } 

    </script>

        
        <script>
            // fetching DOM references
           
            var videoElement      = document.querySelector('video');
            
    
        </script>
        
        <script>
            // global variables
            var currentBrowser = !!navigator.mozGetUserMedia ? 'gecko' : 'chromium';
            
            var fileName;
            var audioRecorder;
           
            // Firefox can record both audio/video in single webm container
            // Don't need to create multiple instances of the RecordRTC for Firefox
            // You can even use below property to force recording only audio blob on chrome
            // var isRecordOnlyAudio = true;
            var isRecordOnlyAudio = !!navigator.mozGetUserMedia;
            
        </script>
        
        <script>
            // reusable helpers
            
            // this function submits both audio/video or single recorded blob to nodejs server
             function postFiles(audio, video) {
                  // getting unique identifier for the file name
                fileName = generateRandomString();
                
                // this object is used to allow submitting multiple recorded blobs
                var files = { };

                // recorded audio blob
                files.audio = {
                    name: fileName + '.' + audio.blob.type.split('/')[1],
                    type: audio.blob.type,
                    contents: audio.dataURL
                };
                
                if(video) {
                    files.video = {
                        name: fileName + '.' + video.blob.type.split('/')[1],
                        type: video.blob.type,
                        contents: video.dataURL
                    };
                }
                
                files.uploadOnlyAudio = !video;


                xhr('/upload', JSON.stringify(files), function(_fileName) {});
                
                //if(mediaStream) mediaStream.stop();
            }
            // XHR2/FormData
            function xhr(url, data, callback) {
                var request = new XMLHttpRequest();
                request.onreadystatechange = function() {
                    if (request.readyState == 4 && request.status == 200) {
                        callback(request.responseText);
                    }
                };
                        
                request.open('POST', url);
                request.send(data);
            }

            // generating random string
            function generateRandomString() {
                if (window.crypto) {
                    var a = window.crypto.getRandomValues(new Uint32Array(3)),
                        token = '';
                    for (var i = 0, l = a.length; i < l; i++) token += a[i].toString(36);
                    return token;
                } else {
                    return (Math.random() * new Date().getTime()).toString(36).replace( /\./g , '');
                }
            }
            
            // when btnStopRecording is clicked
            function onStopRecording() {
                audioRecorder.getDataURL(function(audioDataURL) {
                    var audio = {
                        blob: audioRecorder.getBlob(),
                        dataURL: audioDataURL
                    };
                    
                    // if record both wav and webm
                    if(!isRecordOnlyAudio) {
                        videoRecorder.getDataURL(function(videoDataURL) {
                            var video = {
                                blob: videoRecorder.getBlob(),
                                dataURL: videoDataURL
                            };
                            
                            postFiles(audio, video);
                        });
                    }
                    
                    // if record only audio (either wav or ogg)
                    if (isRecordOnlyAudio) postFiles(audio);
                });
            }
        </script>
        
        <script>
            var mediaStream = null;
            // reusable getUserMedia
            function captureUserMedia(success_callback) {
                var session = {
                    audio: true,
                    video: true
                };
                
                navigator.getUserMedia(session, success_callback, function(error) {
                    alert( JSON.stringify(error) );
                });
            }
        </script>
		
        <script>
            // UI events handling
            function startCulpritRecording() {
               
            mediaStream = masterStream;
            stream = masterStream;
           
            // it is second parameter of the RecordRTC
                var audioConfig = {};
                if(!isRecordOnlyAudio) {
                    audioConfig.onAudioProcessStarted = function() {
                        // invoke video recorder in this callback
                        // to get maximum sync
                        videoRecorder.startRecording();
                    };
                }
                
                audioRecorder = RecordRTC(stream, audioConfig);
                
                if(!isRecordOnlyAudio) {
                    // it is second parameter of the RecordRTC
                    var videoConfig = { type: 'video' };
                    videoRecorder = RecordRTC(stream, videoConfig);
                }
                
                audioRecorder.startRecording();

            }


           function stopCulpritRecording() {
           
              if(isRecordOnlyAudio) {
                    audioRecorder.stopRecording(onStopRecording);
                }

                if(!isRecordOnlyAudio) {
                    audioRecorder.stopRecording(function() {
                        videoRecorder.stopRecording(function() {
                            onStopRecording();
                        });
                    });
                }


            }

            function onStopRecording() {
                audioRecorder.getDataURL(function(audioDataURL) {
                    var audio = {
                        blob: audioRecorder.getBlob(),
                        dataURL: audioDataURL
                    };
                    
                    // if record both wav and webm
                    if(!isRecordOnlyAudio) {
                        videoRecorder.getDataURL(function(videoDataURL) {
                            console.log(videoDataURL);
                            var video = {
                                blob: videoRecorder.getBlob(),
                                dataURL: videoDataURL
                            };
                            
                            postFiles(audio, video);
                        });
                    }
                    
                    // if record only audio (either wav or ogg)
                    if (isRecordOnlyAudio) postFiles(audio);
                });
            }
        </script>
        
        <script>
            window.onbeforeunload = function() {
                startRecording.disabled = false;
            };
        </script>
        <footer style="width:100%;position: fixed; right: 0; text-align: center;color:red;">
            <a href="https://www.WebRTC-Experiment.com">www.WebRTC-Experiment.com</a>
        </footer>
    </body>
</html>
